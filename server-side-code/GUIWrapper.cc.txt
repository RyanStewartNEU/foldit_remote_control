// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
// vi: set ts=2 noet:
//
// (c) Copyright Rosetta Commons Member Institutions.
// (c) This file is part of the Rosetta software suite and is made available under license.
// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.

#include <interactive/application/GUIWrapper.hh>

#include <interactive/application/remote/remote_flags.hh>
#if ENABLE_REMOTE_PLAY
#include <interactive/util/open_gl.hh>
#include <interactive/application/remote/RemoteThread.hh>
#endif

#include <interactive/application/Application.hh>
#include <interactive/application/GUIMutex.hh>
#include <interactive/application/Thread.hh>
#include <interactive/util/general_util.hh>
#include <interactive/gui/Point2D.hh>
#include <interactive/gui/TopLevel.hh>
#include <interactive/sound/SoundSystem.hh>

#include <boost/bind.hpp>
#include <boost/thread/condition.hpp>
#include <boost/thread/mutex.hpp>
#include <assert.h>

namespace interactive {
namespace application {


static const core::Real DOUBLE_CLICK_TIME = 1.0;

const std::string GUIWrapper::DESIRED_WND_TITLE = "Foldit";
int GUIWrapper::DESIRED_WND_WIDTH = 1150;
int GUIWrapper::DESIRED_WND_HEIGHT = 900;
int GUIWrapper::DESIRED_FPS = 45;

static const std::string OPT_DESIRED_WND_WIDTH = "gui/desired_window_width";
static const std::string OPT_DESIRED_WND_HEIGHT = "gui/desired_window_height";
static const std::string OPT_DESIRED_FPS = "gui/desired_fps";

static const int MAX_REMOTE_QUEUE = 30;

GUIWrapper * GUIWrapper::instance_ = NULL;

std::map<int, std::pair<int, int>> pointerMap;

GUIWrapper::GUIWrapper() :
	app_(NULL),
	sound_system_(new sound::SoundSystem()),
	last_frame_time_(0.0),
	fps_(0.0),
	buttons_down_(0),
	left_was_what_(LEFT_WAS_LEFT),
	last_click_button_(0),
	last_click_time_(-1.0),
	image_dir_(""),
	ctrl_left_button_(BUTTON_RIGHT),
	shift_left_button_(BUTTON_MIDDLE),
	alt_left_button_(BUTTON_LEFT),
#if ENABLE_REMOTE_PLAY
	take_screenshot_(false),
	read_buffer(NULL),
	remote_width_(0),
	remote_height_(0),
#endif
	open_urls_(true)
{
	util::Dictionary & options = Application::options_dict();

	options.set_default(OPT_DESIRED_WND_WIDTH, DESIRED_WND_WIDTH);
	options.set_default(OPT_DESIRED_WND_HEIGHT, DESIRED_WND_HEIGHT);
	options.set_default(OPT_DESIRED_FPS, DESIRED_FPS);

	options.get(OPT_DESIRED_WND_WIDTH, DESIRED_WND_WIDTH);
	options.get(OPT_DESIRED_WND_HEIGHT, DESIRED_WND_HEIGHT);
	options.get(OPT_DESIRED_FPS, DESIRED_FPS);

	assert(!instance_);
	instance_ = this;
}

GUIWrapper::~GUIWrapper()
{
	assert(instance_);
	instance_ = NULL;
}

void
GUIWrapper::set_window_title_suffix(const std::string & suffix)
{
}

void
GUIWrapper::set_application(Application::Factory app_factory)
{
	set_application(app_factory());
}

void
GUIWrapper::force_refresh()
{
}

GUIWrapper *
GUIWrapper::instance()
{
	return instance_;
}

Application *
GUIWrapper::get_static_application()
{
	assert(instance_);
	assert(instance_->app_);
	return instance_->get_application();
}

Application *
GUIWrapper::get_application()
{
	return app_;
}

sound::SoundSystem &
GUIWrapper::sound_system()
{
	return *sound_system_;
}

void
GUIWrapper::set_cursor(Cursor cursor)
{
}

void
GUIWrapper::capture_mouse(bool capture)
{
}

void
GUIWrapper::set_take_screenshot(bool setting)
{
	take_screenshot_ = setting;
	if (!read_buffer) {
		take_screenshot_ = false;
	}
}

bool
GUIWrapper::get_modifier(ModifierKey key)
{
#if ENABLE_REMOTE_PLAY
	remote::RemoteThread * remote = remote::RemoteThread::instance();
	if (remote) {
		return remote->get_modifier(key);
	}
#endif
	return false;
}

bool
GUIWrapper::set_clipboard(const std::string & text)
{
	return false;
}

bool
GUIWrapper::get_clipboard(std::string & text)
{
	return false;
}

const std::string &
GUIWrapper::get_desktop_dir() const
{
	HOLD_GUI_MUTEX;

	return desktop_dir_;
}

const std::string &
GUIWrapper::get_image_dir() const
{
	HOLD_GUI_MUTEX;

	return image_dir_;
}

void
GUIWrapper::set_desktop_dir(const std::string desktop_dir)
{
	HOLD_GUI_MUTEX;

	desktop_dir_ = desktop_dir;
}

void
GUIWrapper::set_image_dir(const std::string image_dir)
{
	HOLD_GUI_MUTEX;

	image_dir_ = image_dir;
}

const std::string &
GUIWrapper::get_file_dir() const
{
	HOLD_GUI_MUTEX;

	return file_dir_;
}

void
GUIWrapper::set_file_dir(const std::string & file_dir)
{
	HOLD_GUI_MUTEX;

	file_dir_ = file_dir;
}

static
void
load_or_save_single_as_multiple(const std::string single_file, GUIWrapper::LoadOrSaveMultipleCallback callback)
{
	utility::vector1< std::string > multiple_files;
	multiple_files.push_back(single_file);
	callback(multiple_files);
}

void
GUIWrapper::load_file_mult(const std::string & default_desc, const std::string & default_ext, LoadOrSaveMultipleCallback load_callback)
{
	load_file(default_desc, default_ext, boost::bind(load_or_save_single_as_multiple, _1, load_callback));
}

void
GUIWrapper::open_url(const std::string & url)
{
	std::cout << url << std::endl;
	std::cout << "open_url() not supported by: " << typeid(*this).name() << std::endl;
}

core::Real
GUIWrapper::fps()
{
	return fps_;
}

void
GUIWrapper::clear_event_queue()
{
	HOLD_GUI_MUTEX;

	// worker_thread_->clear_event_queue();
}

void
GUIWrapper::enqueue_event(EventCallback ev)
{
	HOLD_GUI_MUTEX;

	ev();
	//worker_thread_->enqueue_event(ev);
}
    
#if ENABLE_REMOTE_PLAY
void
GUIWrapper::enqueue_remote_event(EventCallback ev)
{
	HOLD_GUI_MUTEX;
    
	if (remote_events_.size() < MAX_REMOTE_QUEUE) {
		remote_events_.push(ev);
	}
}
#endif

void
GUIWrapper::generic_mouse_motion_func(int x, int y)
{
	HOLD_GUI_MUTEX;

	last_click_button_ = 0;
	get_static_application()->get_top_level()->on_mouse_move(gui::Point2D(x, y), buttons_down_);
}

void
GUIWrapper::generic_mouse_aux_motion_func(int id, int x, int y)
{
	HOLD_GUI_MUTEX;


	std::cout << "Called generic_mouse_aux_motion_func" << std::endl;

	// Keep track of the pointer with the x and y coordinates
	pointerMap[id] = std::make_pair(x, y);


	if (id == 0) {
		GUIWrapper::generic_mouse_motion_func(x, y);
	}
	else if (id == 1) {

	}
	else if (id == 2) {

	}
}

void
GUIWrapper::generic_mouse_button_func(int button, bool down, int x, int y)
{
	HOLD_GUI_MUTEX;

	int guibutton = button;

	if (guibutton == BUTTON_LEFT) {
		if (down) {
/*
			if (get_modifier(MODKEY_CONTROL)) {
				guibutton = BUTTON_RIGHT;
				left_was_what_ = LEFT_WAS_RIGHT;
			} else if (get_modifier(MODKEY_SHIFT)) {
				guibutton = BUTTON_MIDDLE;
				left_was_what_ = LEFT_WAS_MIDDLE;
			} else {
				left_was_what_ = LEFT_WAS_LEFT;
			}
*/
			if (get_modifier(MODKEY_CONTROL)) {
				guibutton = ctrl_left_button_;
				if(ctrl_left_button_ == BUTTON_RIGHT)
					left_was_what_ = LEFT_WAS_RIGHT;
				else if(ctrl_left_button_ == BUTTON_MIDDLE)
					left_was_what_ = LEFT_WAS_MIDDLE;
				else
					left_was_what_ = LEFT_WAS_LEFT;
			} else if (get_modifier(MODKEY_SHIFT)) {
				guibutton = shift_left_button_;
				if(shift_left_button_ == BUTTON_RIGHT)
					left_was_what_ = LEFT_WAS_RIGHT;
				else if(shift_left_button_ == BUTTON_MIDDLE)
					left_was_what_ = LEFT_WAS_MIDDLE;
				else
					left_was_what_ = LEFT_WAS_LEFT;
			} else if (get_modifier(MODKEY_ALT)) {
				guibutton = alt_left_button_;
				if(alt_left_button_ == BUTTON_RIGHT)
					left_was_what_ = LEFT_WAS_RIGHT;
				else if(alt_left_button_ == BUTTON_MIDDLE)
					left_was_what_ = LEFT_WAS_MIDDLE;
				else
					left_was_what_ = LEFT_WAS_LEFT;				
			} else {
				left_was_what_ = LEFT_WAS_LEFT;
			}

		} else {
			if (left_was_what_ == LEFT_WAS_RIGHT) {
				guibutton = BUTTON_RIGHT;
			} else if (left_was_what_ == LEFT_WAS_MIDDLE) {
				guibutton = BUTTON_MIDDLE;
			}
		}
	}

	//if (down && !(buttons_down_ & guibutton)) {
	if (down && buttons_down_ == 0) {
		bool is_double = false;
		core::Real click_time = util::time_in_seconds();
		if (last_click_button_ == guibutton && (click_time - last_click_time_) <= DOUBLE_CLICK_TIME) {
			is_double = true;
			last_click_button_ = 0;
		} else {
			last_click_button_ = guibutton;
			last_click_time_ = click_time;
		}

		buttons_down_ |= guibutton;
		get_static_application()->get_top_level()->on_mouse_down(gui::Point2D(x, y), guibutton, is_double);
	} else if (!down && (buttons_down_ & guibutton)) {
		buttons_down_ &= ~guibutton;
		get_static_application()->get_top_level()->on_mouse_up(gui::Point2D(x, y), guibutton);
	}

	if (buttons_down_) {
		capture_mouse(true);
	} else {
		capture_mouse(false);
	}
}



 void
 GUIWrapper::generic_mouse_aux_button_func(int id, int button, bool down, int x, int y)
 {
	 HOLD_GUI_MUTEX;

	 std::cout << "Called generic_mouse_button_func_aux" << std::endl;

	 // Keep track of the pointer with the x and y coordinates
	 pointerMap[id] = std::make_pair(x, y);


	 if (id == 0) {
		 //GUIWrapper::generic_mouse_motion_func(x, y); -- throws an error because non-static?
		 std::cout << "debug - id 0" << std::endl;
	 }
	 else if (id == 1) {

		 std::cout << "debug - id 1" << std::endl;

	 }
	 else if (id == 2) {
		 std::cout << "debug - id 2" << std::endl;

	 }
 
 }


void
GUIWrapper::set_left_remap(int ctrl, int alt, int shift)
{
	ctrl_left_button_ = ctrl;
	alt_left_button_ = alt;
	shift_left_button_ = shift;
}

void
GUIWrapper::load_options(util::Dictionary & options)
{
}

void
GUIWrapper::generic_mouse_wheel_func(int delta)
{
	HOLD_GUI_MUTEX;
	
	get_static_application()->get_top_level()->on_mouse_wheel(gui::Point2D(0.0, 0.0), delta);
}

void
GUIWrapper::generic_text_func(unsigned char text)
{
	HOLD_GUI_MUTEX;
	std::cout << "Generic text func text: " << text << std::endl;
	get_static_application()->get_top_level()->on_text(text);
}

void
GUIWrapper::generic_key_down_func(Key key)
{
	HOLD_GUI_MUTEX;
	
	get_static_application()->get_top_level()->on_key_down(key);
}

void
GUIWrapper::set_application(Application * app)
{
	assert(app_ == NULL);
	app_ = app;	
}

void
GUIWrapper::tick_frame()
{
	HOLD_GUI_MUTEX;

	core::Real current_frame_time = util::time_in_seconds();
	core::Real new_fps = 1.0 / (current_frame_time - last_frame_time_);
	const static core::Real FPS_INERTIA = 0.90;
	fps_ = FPS_INERTIA * fps_ + (1.0 - FPS_INERTIA) * new_fps;
	last_frame_time_ = current_frame_time;
	if (app_) {
		app_->update(current_frame_time);
	}
    
#if ENABLE_REMOTE_PLAY
	while (!remote_events_.empty()) {
		remote_events_.front()(); // execute event
		remote_events_.pop();
	}
#endif
}

void
GUIWrapper::on_post_render()
{
#if ENABLE_REMOTE_PLAY
	if (take_screenshot_) {
		glReadPixels(0, 0, remote_width_, remote_height_, GL_RGBA, GL_UNSIGNED_BYTE, read_buffer);
	}
	//else if (read_buffer) {
	//	delete[] read_buffer;
	//	read_buffer = NULL;
	//	remote_width_ = 0;
	//	remote_height_ = 0;
	//}
#endif
}

#if ENABLE_REMOTE_PLAY
unsigned char *
GUIWrapper::remote_read(int width, int height)
{
	remote_width_ = width;
	remote_height_ = height;
	read_buffer = new unsigned char[width * height * 4];
	return read_buffer;
}

void
GUIWrapper::set_open_urls(bool setting)
{
	open_urls_ = setting;
}
#endif



} /* application */
} /* interactive */
